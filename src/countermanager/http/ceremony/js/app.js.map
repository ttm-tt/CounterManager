{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["/*!\n * FlagWaver - App\n * @author krikienoid / https://github.com/krikienoid\n */\n\n(function (THREE) {\n    'use strict';\n\n    THREE = THREE && THREE.hasOwnProperty('default') ? THREE['default'] : THREE;\n\n    //\n    // Static constants\n    //\n    // Physics constants\n    // ChT: We animate the flags in slow motion: they wave quieter as if the wind speed\n    // were lowwer, but they still wouldn't hang down.\n    var FPS = 30;\n    var TIME_STEP = 1 / FPS;\n    var DAMPING = 0.03;\n    var DRAG = 1 - DAMPING;\n\n    var G = 9.80665; // m/s^2\n\n    /**\n     * Enum for flag hoisting side.\n     *\n     * @readonly\n     * @enum {string}\n     * @typedef {string} Hoisting\n     */\n\n    var Hoisting = {\n      DEXTER: 'dexter',\n      SINISTER: 'sinister'\n    };\n    /**\n     * Enum for cardinal directions.\n     *\n     * @readonly\n     * @enum {string}\n     * @typedef {string} Side\n     */\n\n    var Side = {\n      TOP: 'top',\n      LEFT: 'left',\n      BOTTOM: 'bottom',\n      RIGHT: 'right'\n    };\n    /**\n     * Enum for flagpole types.\n     *\n     * @readonly\n     * @enum {string}\n     * @typedef {string} FlagpoleType\n     */\n\n    var FlagpoleType = {\n      VERTICAL: 'vertical',\n      HORIZONTAL: 'horizontal',\n      OUTRIGGER: 'outrigger',\n      CROSSBAR: 'crossbar',\n      GALLERY: 'gallery',\n      AUSTRALIAN: 'australian'\n    };\n\n    function _typeof(obj) {\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function (obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function (obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    function _defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    function _createClass(Constructor, protoProps, staticProps) {\n      if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) _defineProperties(Constructor, staticProps);\n      return Constructor;\n    }\n\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n\n    function _getPrototypeOf(o) {\n      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      };\n      return _getPrototypeOf(o);\n    }\n\n    function _setPrototypeOf(o, p) {\n      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n      };\n\n      return _setPrototypeOf(o, p);\n    }\n\n    function _assertThisInitialized(self) {\n      if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return self;\n    }\n\n    function _possibleConstructorReturn(self, call) {\n      if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n        return call;\n      }\n\n      return _assertThisInitialized(self);\n    }\n\n    function generateDataTexture(width, height, color) {\n      var size = width * height;\n      var data = new Uint8Array(3 * size);\n      var r = Math.floor(color.r * 255);\n      var g = Math.floor(color.g * 255);\n      var b = Math.floor(color.b * 255);\n\n      for (var i = 0; i < size; i++) {\n        var stride = i * 3;\n        data[stride] = r;\n        data[stride + 1] = g;\n        data[stride + 2] = b;\n      }\n\n      var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);\n      return texture;\n    }\n\n    var isNumeric = function isNumeric(value) {\n      return !isNaN(parseFloat(value)) && isFinite(value);\n    }; // Is an object\n\n    var isObject = function isObject(object) {\n      return !!(object && _typeof(object) === 'object');\n    }; // Object has property\n\n    var hasValue = function hasValue(object, value) {\n      return isObject(object) && Object.keys(object).some(function (key) {\n        return object[key] === value;\n      });\n    }; // Is a function\n\n    var depth_frag = \"uniform sampler2D texture;\\nvarying vec2 vUV;\\nvec4 pack_depth(const in float depth) {\\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\\n    const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\\n    vec4 res = fract(depth * bit_shift);\\n    res -= res.xxyz * bit_mask;\\n    return res;\\n}\\nvoid main() {\\n    vec4 pixel = texture2D(texture, vUV);\\n    if (pixel.a < 0.5) discard;\\n    gl_FragData[0] = pack_depth(gl_FragCoord.z);\\n}\\n\";\n\n    var depth_vert = \"varying vec2 vUV;\\nvoid main() {\\n    vUV = 0.75 * uv;\\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n    gl_Position = projectionMatrix * mvPosition;\\n}\\n\";\n\n    /**\n     * @module ShaderChunk\n     */\n\n    var ShaderChunk = {\n      depth_frag: depth_frag,\n      depth_vert: depth_vert\n    };\n\n    /**\n     * @class Particle\n     *\n     * @classdesc Represents a mass in a mass-spring system.\n     *\n     * @param {THREE.Vector3} position\n     * @param {number} mass\n     */\n\n    var Particle =\n    /*#__PURE__*/\n    function () {\n      function Particle(position, mass) {\n        _classCallCheck(this, Particle);\n\n        this.position = position.clone();\n        this.previous = position.clone();\n        this.original = position.clone();\n        this.mass = mass;\n        this.inverseMass = 1 / mass;\n        this.acceleration = new THREE.Vector3();\n        this.tmp = new THREE.Vector3();\n      } // Apply force\n\n\n      _createClass(Particle, [{\n        key: \"applyForce\",\n        value: function applyForce(force) {\n          this.acceleration.addScaledVector(force, this.inverseMass);\n        } // Compute new position\n\n      }, {\n        key: \"integrate\",\n        value: function integrate(deltaTimeSq) {\n          // Perform verlet integration\n          var tmp = this.tmp.subVectors(this.position, this.previous).multiplyScalar(DRAG).add(this.position).addScaledVector(this.acceleration, deltaTimeSq);\n          this.tmp = this.previous;\n          this.previous = this.position;\n          this.position = tmp;\n          this.acceleration.set(0, 0, 0);\n        }\n      }]);\n\n      return Particle;\n    }();\n\n    var diff = new THREE.Vector3();\n    /**\n     * @class Constraint\n     *\n     * @classdesc Represents a spring constraint in a mass-spring system.\n     *\n     * @param {Particle} p1\n     * @param {Particle} p2\n     * @param {number} restDistance\n     */\n\n    var Constraint =\n    /*#__PURE__*/\n    function () {\n      function Constraint(p1, p2, restDistance) {\n        _classCallCheck(this, Constraint);\n\n        this.p1 = p1;\n        this.p2 = p2;\n        this.restDistance = restDistance;\n      }\n\n      _createClass(Constraint, [{\n        key: \"resolve\",\n        value: function resolve() {\n          var p1 = this.p1;\n          var p2 = this.p2;\n          var restDistance = this.restDistance;\n          diff.subVectors(p2.position, p1.position);\n          var currentDistance = diff.length();\n\n          if (currentDistance === 0) {\n            return;\n          } // Prevents division by 0\n\n\n          var correction = diff.multiplyScalar((1 - restDistance / currentDistance) / 2);\n          p1.position.add(correction);\n          p2.position.sub(correction);\n        }\n      }]);\n\n      return Constraint;\n    }();\n\n    /**\n     * @class Cloth\n     *\n     * @classdesc Simulates the physics of a rectangular cloth using\n     * a mass-spring system.\n     *\n     * @param {number} xSegments - Number of nodes along the x-axis\n     * @param {number} ySegments - Number of nodes along the y-axis\n     * @param {number} restDistance - Rest distance between adjacent nodes\n     * @param {number} mass - Mass of the cloth material\n     */\n\n    var Cloth =\n    /*#__PURE__*/\n    function () {\n      function Cloth(xSegments, ySegments, restDistance, mass) {\n        _classCallCheck(this, Cloth);\n\n        // Cloth properties\n        var width = restDistance * xSegments;\n        var height = restDistance * ySegments;\n        var particles = [];\n        var constraints = []; // Get particle at position (u, v)\n\n        var particleAt = function particleAt(u, v) {\n          return particles[u + v * (xSegments + 1)];\n        }; // Cloth plane function\n\n\n        var plane = function plane(u, v, target) {\n          target.set(u * width, v * height, 0);\n        }; //\n        // Particles\n        //\n\n\n        var position = new THREE.Vector3();\n\n        for (var v = 0; v <= ySegments; v++) {\n          for (var u = 0; u <= xSegments; u++) {\n            plane(u / xSegments, v / ySegments, position);\n            particles.push(new Particle(position, mass));\n          }\n        } //\n        // Constraints\n        //\n        // Structural constraints\n\n\n        for (var _v = 0; _v < ySegments; _v++) {\n          for (var _u = 0; _u < xSegments; _u++) {\n            constraints.push(new Constraint(particleAt(_u, _v), particleAt(_u, _v + 1), restDistance));\n            constraints.push(new Constraint(particleAt(_u, _v), particleAt(_u + 1, _v), restDistance));\n          }\n        }\n\n        for (var _u2 = xSegments, _v2 = 0; _v2 < ySegments; _v2++) {\n          constraints.push(new Constraint(particleAt(_u2, _v2), particleAt(_u2, _v2 + 1), restDistance));\n        }\n\n        for (var _v3 = ySegments, _u3 = 0; _u3 < xSegments; _u3++) {\n          constraints.push(new Constraint(particleAt(_u3, _v3), particleAt(_u3 + 1, _v3), restDistance));\n        }\n        /*\n         * While many systems use shear and bend springs, the\n         * relax constraints model seems to be just fine using\n         * structural springs.\n         */\n        // Shear constraints\n\n\n        var diagonalDistance = Math.sqrt(restDistance * restDistance * 2);\n\n        for (var _v4 = 0; _v4 < ySegments; _v4++) {\n          for (var _u4 = 0; _u4 < xSegments; _u4++) {\n            constraints.push(new Constraint(particleAt(_u4, _v4), particleAt(_u4 + 1, _v4 + 1), diagonalDistance));\n            constraints.push(new Constraint(particleAt(_u4 + 1, _v4), particleAt(_u4, _v4 + 1), diagonalDistance));\n          }\n        } // Bend constraints\n        // ChT: Use both, not only shear\n\n        /* */\n        //\n\n\n        var x2Distance = restDistance * 2;\n        var y2Distance = restDistance * 2;\n        var diagonalDistance2 = Math.sqrt(x2Distance * x2Distance + y2Distance * y2Distance);\n\n        for (var _v5 = 0; _v5 < ySegments - 1; _v5++) {\n          for (var _u5 = 0; _u5 < xSegments - 1; _u5++) {\n            constraints.push(new Constraint(particleAt(_u5, _v5), particleAt(_u5 + 2, _v5), x2Distance));\n            constraints.push(new Constraint(particleAt(_u5, _v5), particleAt(_u5, _v5 + 2), y2Distance));\n            constraints.push(new Constraint(particleAt(_u5, _v5), particleAt(_u5 + 2, _v5 + 2), diagonalDistance2));\n            constraints.push(new Constraint(particleAt(_u5, _v5 + 2), particleAt(_u5 + 2, _v5 + 2), x2Distance));\n            constraints.push(new Constraint(particleAt(_u5 + 2, _v5 + 2), particleAt(_u5 + 2, _v5 + 2), y2Distance));\n            constraints.push(new Constraint(particleAt(_u5 + 2, _v5), particleAt(_u5, _v5 + 2), diagonalDistance2));\n          }\n        } // /* */\n        //\n        // Geometry\n        //\n\n\n        var geometry = new THREE.ParametricGeometry(plane, xSegments, ySegments, true);\n        geometry.dynamic = true;\n        geometry.computeFaceNormals(); // Public properties and methods\n\n        this.xSegments = xSegments;\n        this.ySegments = ySegments;\n        this.restDistance = restDistance;\n        this.width = width;\n        this.height = height;\n        this.particles = particles;\n        this.constraints = constraints;\n        this.particleAt = particleAt;\n        this.geometry = geometry;\n      }\n\n      _createClass(Cloth, [{\n        key: \"reset\",\n        value: function reset() {\n          var particles = this.particles;\n\n          for (var i = 0, ii = particles.length; i < ii; i++) {\n            var particle = particles[i];\n            particle.previous.copy(particle.position.copy(particle.original));\n          }\n        }\n      }, {\n        key: \"simulate\",\n        value: function simulate(deltaTime) {\n          var particles = this.particles;\n          var constraints = this.constraints;\n          var deltaTimeSq = deltaTime * deltaTime; // Compute new particle positions\n\n          for (var i = 0, ii = particles.length; i < ii; i++) {\n            particles[i].integrate(deltaTimeSq);\n          } // Resolve constraints\n\n\n          for (var _i = 0, _ii = constraints.length; _i < _ii; _i++) {\n            constraints[_i].resolve();\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var particles = this.particles;\n          var geometry = this.geometry;\n          var vertices = geometry.vertices;\n\n          for (var i = 0, ii = particles.length; i < ii; i++) {\n            vertices[i].copy(particles[i].position);\n          }\n\n          geometry.computeFaceNormals();\n          geometry.computeVertexNormals();\n          geometry.normalsNeedUpdate = true;\n          geometry.verticesNeedUpdate = true;\n        }\n      }]);\n\n      return Cloth;\n    }();\n\n    var SLACK = 1.2;\n    var diff$1 = new THREE.Vector3();\n    /**\n     * @class FixedConstraint\n     *\n     * @classdesc A unidirectional spring constraint used to mitigate\n     * the \"super elastic\" effect.\n     *\n     * @param {Particle} p1\n     * @param {Particle} p2\n     * @param {number} restDistance\n     */\n\n    var FixedConstraint =\n    /*#__PURE__*/\n    function (_Constraint) {\n      _inherits(FixedConstraint, _Constraint);\n\n      function FixedConstraint() {\n        _classCallCheck(this, FixedConstraint);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(FixedConstraint).apply(this, arguments));\n      }\n\n      _createClass(FixedConstraint, [{\n        key: \"resolve\",\n        // Satisfy constraint unidirectionally\n        value: function resolve() {\n          var p1 = this.p1;\n          var p2 = this.p2;\n          var restDistance = this.restDistance * SLACK;\n          diff$1.subVectors(p1.position, p2.position);\n          var currentDistance = diff$1.length() / SLACK;\n          diff$1.normalize();\n          var correction = diff$1.multiplyScalar(currentDistance - restDistance);\n\n          if (currentDistance > restDistance) {\n            p2.position.add(correction);\n          }\n        }\n      }]);\n\n      return FixedConstraint;\n    }(Constraint);\n\n    var WHITE_TEXTURE = generateDataTexture(1, 1, new THREE.Color(0xffffff));\n\n    function buildCloth(options) {\n      var restDistance = options.height / options.granularity;\n      return new Cloth(Math.round(options.width / restDistance), Math.round(options.height / restDistance), restDistance, options.mass);\n    }\n\n    function buildMesh(cloth, options) {\n      var texture = WHITE_TEXTURE;\n      var geometry = cloth.geometry; // Texture\n\n      if (options && options.texture) {\n        if (options.texture instanceof THREE.Texture) {\n          texture = options.texture;\n          texture.needsUpdate = true;\n          texture.anisotropy = 16;\n          texture.minFilter = THREE.LinearFilter;\n          texture.magFilter = THREE.LinearFilter;\n          texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;\n        } else {\n          console.error('FlagWaver.Flag: options.texture must be an instance of THREE.Texture.');\n        }\n      } // Material\n\n\n      var material = new THREE.MeshPhongMaterial({\n        alphaTest: 0.5,\n        color: 0xffffff,\n        specular: 0x030303,\n\n        /*\n         * shininess cannot be 0 as it causes bugs in some systems.\n         * https://github.com/mrdoob/three.js/issues/7252\n         */\n        shininess: 0.001,\n        side: THREE.DoubleSide,\n        map: texture\n      });\n      /* //\n      material = new THREE.MeshBasicMaterial({\n          color:       0x00ff00,\n          wireframe:   true,\n          transparent: true,\n          opacity:     0.9\n      });\n      // */\n      // Mesh\n\n      var mesh = new THREE.Mesh(geometry, material);\n      mesh.castShadow = true;\n      mesh.customDepthMaterial = new THREE.ShaderMaterial({\n        uniforms: {\n          texture: {\n            value: texture\n          }\n        },\n        vertexShader: ShaderChunk.depth_vert,\n        fragmentShader: ShaderChunk.depth_frag\n      });\n      return mesh;\n    }\n\n    var _pin = function () {\n      var defaults = {\n        edges: [],\n        spacing: 1\n      };\n\n      function ensureValidSpacing(spacing) {\n        if (isNumeric(spacing) && spacing >= 1) {\n          return Math.floor(spacing);\n        } else {\n          return defaults.spacing;\n        }\n      }\n\n      function pinEdge(cloth, pins, edge, options) {\n        var xSegments = cloth.xSegments,\n            ySegments = cloth.ySegments,\n            particleAt = cloth.particleAt;\n        var spacing = options.spacing;\n\n        switch (edge) {\n          case Side.TOP:\n            for (var i = 0; i <= xSegments; i += spacing) {\n              pins.push(particleAt(i, ySegments));\n            }\n\n            break;\n\n          case Side.LEFT:\n            for (var _i = 0; _i <= ySegments; _i += spacing) {\n              pins.push(particleAt(0, _i));\n            }\n\n            break;\n\n          case Side.BOTTOM:\n            for (var _i2 = 0; _i2 <= xSegments; _i2 += spacing) {\n              pins.push(particleAt(_i2, 0));\n            }\n\n            break;\n\n          case Side.RIGHT:\n            for (var _i3 = 0; _i3 <= ySegments; _i3 += spacing) {\n              pins.push(particleAt(xSegments, _i3));\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return function pin(cloth, pins, options) {\n        var settings = Object.assign({}, defaults, options);\n        var edges = settings.edges;\n        settings.spacing = ensureValidSpacing(settings.spacing);\n\n        if (typeof edges === 'string') {\n          // If edges is a string\n          pinEdge(cloth, pins, edges, settings);\n        } else if (edges && edges.length) {\n          // If edges is an array\n          for (var i = 0, ii = edges.length; i < ii; i++) {\n            pinEdge(cloth, pins, edges[i], settings);\n          }\n        }\n      };\n    }();\n    /**\n     * @class Flag\n     *\n     * @classdesc Initializes a cloth object to simulate the motion of a flag\n     * and applies the cloth geometry to a mesh.\n     *\n     * @param {Object} [options]\n     *   @param {number} [options.width]\n     *   @param {number} [options.height]\n     *   @param {number} [options.mass]\n     *   @param {number} [options.granularity]\n     *   @param {THREE.Texture} [options.texture]\n     *   @param {Object} [options.pin]\n     */\n\n\n    var Flag =\n    /*#__PURE__*/\n    function () {\n      function Flag(options) {\n        _classCallCheck(this, Flag);\n\n        var settings = Object.assign({}, Flag.defaults, options);\n        this.cloth = buildCloth(settings);\n        this.pins = [];\n        this.lengthConstraints = [];\n        this.mesh = buildMesh(this.cloth, settings);\n        this.mesh.position.set(0, -this.cloth.height, 0);\n        this.object = new THREE.Object3D();\n        this.object.add(this.mesh);\n        this.pin(settings.pin);\n      }\n\n      _createClass(Flag, [{\n        key: \"destroy\",\n        value: function destroy() {\n          if (this.mesh instanceof THREE.Mesh) {\n            this.mesh.material.dispose();\n            this.mesh.geometry.dispose();\n            this.mesh.material.map.dispose();\n            this.mesh.customDepthMaterial.dispose();\n          }\n        }\n      }, {\n        key: \"pin\",\n        value: function pin(options) {\n          _pin(this.cloth, this.pins, options);\n        }\n      }, {\n        key: \"unpin\",\n        value: function unpin() {\n          this.pins = [];\n        } // Add additional constraints to cloth to mitigate stretching\n\n      }, {\n        key: \"setLengthConstraints\",\n        value: function setLengthConstraints(hoistwardSide) {\n          var _this$cloth = this.cloth,\n              xSegments = _this$cloth.xSegments,\n              ySegments = _this$cloth.ySegments,\n              restDistance = _this$cloth.restDistance,\n              particleAt = _this$cloth.particleAt;\n          var lengthConstraints = [];\n          /*\n           * Order is important, constraints closest to the hoist must be\n           * resolved first.\n           */\n\n          if (hoistwardSide === Side.LEFT) {\n            // Add horizontal constraints that run from hoist to fly\n            for (var v = 0; v <= ySegments; v++) {\n              for (var u = 0; u < xSegments; u++) {\n                lengthConstraints.push(new FixedConstraint(particleAt(u, v), particleAt(u + 1, v), restDistance));\n              }\n            }\n          } else if (hoistwardSide === Side.TOP) {\n            // Add vertical constraints that run from top to bottom\n            for (var _u = 0; _u <= xSegments; _u++) {\n              for (var _v = ySegments; _v > 0; _v--) {\n                lengthConstraints.push(new FixedConstraint(particleAt(_u, _v), particleAt(_u, _v - 1), restDistance));\n              }\n            }\n          }\n\n          this.lengthConstraints = lengthConstraints;\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          this.cloth.reset();\n        }\n      }, {\n        key: \"simulate\",\n        value: function simulate(deltaTime) {\n          var pins = this.pins;\n          var lengthConstraints = this.lengthConstraints;\n          this.cloth.simulate(deltaTime); // Pin constraints\n\n          for (var i = 0, ii = pins.length; i < ii; i++) {\n            var particle = pins[i];\n            particle.previous.copy(particle.position.copy(particle.original));\n          } // Length constraints\n\n\n          for (var _i4 = 0, _ii = lengthConstraints.length; _i4 < _ii; _i4++) {\n            lengthConstraints[_i4].resolve();\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          this.cloth.render();\n        }\n      }]);\n\n      return Flag;\n    }();\n\n    Flag.defaults = {\n      width: 300,\n      height: 200,\n      mass: 0.1,\n      granularity: 10,\n      rigidness: 1,\n      texture: WHITE_TEXTURE,\n      pin: {\n        edges: [Side.LEFT]\n      }\n    };\n\n    /**\n     * @module WindModifiers\n     *\n     * @description A collection of optional functions for customizing\n     * wind behavior.\n     */\n    var WindModifiers = {\n      noEffect: function noEffect(x) {\n        return x;\n      },\n      blowFromLeftDirection: function blowFromLeftDirection(direction, time) {\n        return direction.set(2000, 0, 1000);\n      },\n      rotatingDirection: function rotatingDirection(direction, time) {\n        return direction.set(Math.sin(time / 2000), Math.cos(time / 3000), Math.sin(time / 1000));\n      },\n      constantSpeed: function constantSpeed(speed, time) {\n        return speed;\n      },\n      variableSpeed: function variableSpeed(speed, time) {\n        return Math.cos(time / 7000) * (speed / 2) + speed;\n      }\n    };\n\n    // in the simulation. Use this function to induce minor disruptions.\n\n    function disturbVector(v) {\n      if (v.x === 0) {\n        v.x = 0.001;\n      }\n\n      if (v.y === 0) {\n        v.y = 0.001;\n      }\n\n      if (v.z === 0) {\n        v.z = 0.001;\n      }\n\n      return v;\n    }\n\n    function disturbScalar(n) {\n      return n === 0 ? 0.001 : n;\n    }\n    /**\n     * @class Wind\n     *\n     * @param {Object} [options]\n     *   @param {THREE.Vector3} [options.direction]\n     *   @param {number} [options.speed]\n     *   @param {Function} [options.directionFn]\n     *   @param {Function} [options.speedFn]\n     */\n\n\n    var Wind =\n    /*#__PURE__*/\n    function () {\n      function Wind(options) {\n        _classCallCheck(this, Wind);\n\n        var settings = Object.assign({}, this.constructor.defaults, options);\n        this.direction = settings.direction;\n        this.speed = settings.speed;\n        this.directionFn = settings.directionFn;\n        this.speedFn = settings.speedFn;\n        this.force = new THREE.Vector3();\n      }\n\n      _createClass(Wind, [{\n        key: \"update\",\n        value: function update() {\n          var time = Date.now();\n          this.directionFn(disturbVector(this.force.copy(this.direction)), time).normalize().multiplyScalar(this.speedFn(disturbScalar(this.speed), time));\n        }\n      }]);\n\n      return Wind;\n    }();\n\n    Wind.defaults = {\n      direction: new THREE.Vector3(1, 0, 0),\n      speed: 100,\n      directionFn: WindModifiers.blowFromLeftDirection,\n      speedFn: WindModifiers.constantSpeed\n    };\n\n    var loader = new THREE.ImageLoader();\n    loader.setCrossOrigin('anonymous');\n    /**\n     * @function loadImage\n     *\n     * @description Helper for loading CORS enabled images.\n     *\n     * @param {string} src\n     * @param {Function} [callback]\n     * @param {Function} [error]\n     */\n\n    function loadImage(src, callback, error) {\n      var url = window.imageLocation + '/' + src + '.png';\n      loader.load(url, callback, null, function (e) {\n        console.error(\"FlagWaver.loadImage: Failed to load image from \".concat(src, \".\"));\n\n        if (error) {\n          error(e);\n        }\n      });\n    }\n\n    function getAngleOfSide(side) {\n      switch (side) {\n        case Side.TOP:\n          return 0;\n\n        case Side.LEFT:\n          return -Math.PI / 2;\n\n        case Side.BOTTOM:\n          return Math.PI;\n\n        case Side.RIGHT:\n          return Math.PI / 2;\n\n        default:\n          return 0;\n      }\n    }\n\n    var defaults = {\n      width: 'auto',\n      height: 'auto',\n      hoisting: Hoisting.DEXTER,\n      orientation: Side.TOP\n    }; // Calculate width and/or height from image if either is set to 'auto'\n\n    function computeSizeFromImage(image, options) {\n      if (options.width === 'auto' && options.height === 'auto') {\n        // Distance between flag poles is innerWidth * 0.24\n        var crossWidth = window.innerWidth * 0.21;\n\n        if (image.width < image.height) {\n          // Vertical\n          return {\n            width: crossWidth,\n            height: crossWidth * image.width / image.height\n          };\n        } else {\n          // Horizontal or square\n          return {\n            width: crossWidth,\n            height: crossWidth * image.height / image.width\n          };\n        }\n      } else if (options.width === 'auto' && isNumeric(options.height)) {\n        return {\n          width: options.height * image.width / image.height,\n          height: options.height\n        };\n      } else if (isNumeric(options.width) && options.height === 'auto') {\n        return {\n          width: options.width,\n          height: options.width * image.height / image.width\n        };\n      } else {\n        return {\n          width: options.width,\n          height: options.height\n        };\n      }\n    } // Compute a numeric width and height from options\n\n\n    function computeSize(image, options) {\n      var size = {\n        width: options.width,\n        height: options.height\n      };\n\n      if (image) {\n        size = computeSizeFromImage(image, size);\n      }\n\n      if (isNumeric(size.width) && isNumeric(size.height)) {\n        return size;\n      } else {\n        return {\n          width: Flag.defaults.width,\n          height: Flag.defaults.height\n        };\n      }\n    } // Check if flag has been rotated into a vertical position\n\n\n    function isVertical(options) {\n      return options.orientation === Side.LEFT || options.orientation === Side.RIGHT;\n    } // Compute values needed to apply texture onto mesh\n\n\n    function computeTextureArgs(options) {\n      var result = {};\n      result.reflect = options.hoisting === Hoisting.SINISTER;\n      result.rotate = getAngleOfSide(options.orientation);\n      return result;\n    } // Generate transformed texture from image\n\n\n    function createTextureFromImage(image, options) {\n      var texture = new THREE.Texture(image);\n      texture.matrixAutoUpdate = false;\n\n      if (isObject(options)) {\n        var matrix = texture.matrix;\n        matrix.scale(1, 1); // Reflect\n\n        if (options.reflect) {\n          matrix.translate(-1, 0).scale(-1, 1);\n        } // Rotate around center\n\n\n        if (isNumeric(options.rotate)) {\n          matrix.translate(-0.5, -0.5).rotate(-options.rotate).translate(0.5, 0.5);\n        }\n      }\n\n      return texture;\n    } // Compute values needed to create new flag\n\n\n    function computeFlagArgs(image, options) {\n      var result = Object.assign({}, options);\n\n      if (isVertical(options)) {\n        result.width = options.height;\n        result.height = options.width;\n      }\n\n      if (image) {\n        result.texture = createTextureFromImage(image, computeTextureArgs(options));\n      }\n\n      return result;\n    }\n    /**\n     * @function buildRectangularFlagFromImage\n     *\n     * @description Helper for generating flags from rectangular designs\n     * that can be rotated and flipped.\n     *\n     * @param {HTMLImageElement} image\n     * @param {Object} [options]\n     */\n\n\n    function buildRectangularFlagFromImage(image, options) {\n      var settings = Object.assign({}, defaults, options);\n      Object.assign(settings, computeSize(image, settings)); // Init models and create meshes once images(s) have loaded\n\n      return new Flag(computeFlagArgs(image, settings));\n    }\n\n    function ensureNumericSize(options) {\n      var result = Object.assign({}, options);\n\n      if (!isNumeric(result.width)) {\n        result.width = Flag.defaults.width;\n      }\n\n      if (!isNumeric(result.height)) {\n        result.height = Flag.defaults.height;\n      }\n\n      return result;\n    }\n    /**\n     * @function buildFlag\n     *\n     * @description Helper for generating flags based on provided image\n     * and options.\n     *\n     * @param {HTMLImageElement} image\n     * @param {Object} [options]\n     */\n\n\n    function buildFlag(image, options) {\n      if (image) {\n        return buildRectangularFlagFromImage(image, options);\n      }\n\n      return new Flag(ensureNumericSize(options));\n    }\n\n    /**\n     * @class FlagInterface\n     *\n     * @classdesc A wrapper object for managing a single flag.\n     *\n     * @param {Object} [options] - Options passed to buildFlag\n     *   @param {string} [options.imgSrc] - Image to generate flag from\n     */\n\n    var FlagInterface =\n    /*#__PURE__*/\n    function () {\n      function FlagInterface(options) {\n        var _this = this;\n\n        _classCallCheck(this, FlagInterface);\n\n        this.flag = buildFlag(null, options);\n        this.object = new THREE.Object3D();\n        this.object.add(this.flag.object);\n        loadImage(options.imgSrc, function (image) {\n          _this.destroy();\n\n          _this.flag = buildFlag(image, options);\n\n          _this.object.add(_this.flag.object);\n        });\n      }\n\n      _createClass(FlagInterface, [{\n        key: \"destroy\",\n        value: function destroy() {\n          if (this.flag) {\n            this.object.remove(this.flag.object);\n            this.flag.destroy();\n          }\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          this.flag.reset();\n        }\n      }, {\n        key: \"simulate\",\n        value: function simulate(deltaTime) {\n          this.flag.simulate(deltaTime);\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          this.flag.render();\n        }\n      }]);\n\n      return FlagInterface;\n    }();\n\n    /**\n     * @function createPoleGeometryTypeI\n     *\n     * @description Build a standard flagpole.\n     *\n     *\n     *   o\n     *   |^^^^^\n     *   |    ^\n     *   |^^^^^\n     *   |\n     *   |\n     *\n     *\n     * @param {Object} options\n     */\n\n    function createPoleGeometryTypeI(options) {\n      var geometry = new THREE.CylinderGeometry(options.poleWidth, options.poleWidth, options.poleLength); // Center\n\n      geometry.translate(0, -options.poleLength / 2, 0); // Add finial cap\n\n      geometry.merge(new THREE.CylinderGeometry(options.poleCapSize, options.poleCapSize, options.poleCapSize));\n      return geometry;\n    }\n\n    /**\n     * @class Flagpole\n     *\n     * @classdesc Creates a geometry, material, and mesh for a flagpole.\n     *\n     * @param {Object} [options]\n     *   @param {FlagpoleType} [options.flagpoleType]\n     *   @param {number} [options.poleWidth]\n     *   @param {number} [options.poleLength]\n     *   @param {number} [options.poleCapSize]\n     *   @param {number} [options.crossbarWidth]\n     *   @param {number} [options.crossbarLength]\n     *   @param {number} [options.crossbarCapSize]\n     *   @param {number} [options.poleTopOffset]\n     */\n\n    var Flagpole =\n    /*#__PURE__*/\n    function () {\n      function Flagpole(options) {\n        _classCallCheck(this, Flagpole);\n\n        var settings = Object.assign({}, this.constructor.defaults, options); // Geometry\n\n        var geometry = this.buildGeometry(settings); // Material\n\n        var material = new THREE.MeshPhongMaterial({\n          color: 0x6A6A6A,\n          specular: 0xffffff,\n          shininess: 18\n        }); // Mesh\n\n        var mesh = new THREE.Mesh(geometry, material);\n        mesh.receiveShadow = true;\n        mesh.castShadow = true;\n        this.mesh = mesh;\n        this.object = this.mesh;\n      }\n\n      _createClass(Flagpole, [{\n        key: \"destroy\",\n        value: function destroy() {\n          if (this.mesh instanceof THREE.Mesh) {\n            this.mesh.material.dispose();\n            this.mesh.geometry.dispose();\n          }\n        }\n      }, {\n        key: \"buildGeometry\",\n        value: function buildGeometry(options) {\n          return createPoleGeometryTypeI(options);\n        }\n      }, {\n        key: \"addFlag\",\n        value: function addFlag(flag) {\n          flag.unpin();\n          flag.pin({\n            edges: [Side.LEFT]\n          });\n          flag.setLengthConstraints(Side.LEFT);\n        }\n      }]);\n\n      return Flagpole;\n    }();\n\n    Flagpole.defaults = function () {\n      var o = {};\n      o.flagpoleType = FlagpoleType.VERTICAL;\n      o.poleWidth = 6;\n      o.poleLength = 8192;\n      o.poleCapSize = o.poleWidth + 2;\n      o.crossbarWidth = o.poleWidth - 2;\n      o.crossbarLength = 200;\n      o.crossbarCapSize = o.crossbarWidth + 2;\n      o.poleTopOffset = 60;\n      return o;\n    }();\n\n    /**\n     * @function buildFlagpole\n     *\n     * @description Helper for generating different types of flagpoles.\n     *\n     * @param {Object} [options]\n     */\n\n    function buildFlagpole(options) {\n      var settings = Object.assign({}, options);\n      var flagpole;\n      flagpole = new Flagpole(settings);\n      return flagpole;\n    }\n\n    /**\n     * @class FlagGroupInterface\n     *\n     * @classdesc A wrapper object for managing a flagpole and flag.\n     *\n     * @param {Object} [options] - Options passed to buildFlag and buildFlagpole\n     */\n\n    var FlagGroupInterface =\n    /*#__PURE__*/\n    function () {\n      function FlagGroupInterface(options) {\n        _classCallCheck(this, FlagGroupInterface);\n\n        // ChT: the duration to raise the 1st place flag\n        this.duration = options.duration;\n        this.object = new THREE.Object3D();\n        this.flagpole = buildFlagpole({});\n        this.flagInterfaces = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = options.imgSrc.split(',')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var src = _step.value;\n            this.flagInterfaces.push(new FlagInterface({\n              imgSrc: src\n            }));\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        this.object.add(this.flagpole.object);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.flagInterfaces[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var flagInterface = _step2.value;\n            this.object.add(flagInterface.object);\n            this.flagpole.addFlag(flagInterface.flag);\n          }\n          /*\n                  this.setFlagpoleOptions(options);\n                  this.setFlagOptions(options);\n           */\n          // ChT: We need our own clock to raise the flag in real time,\n          // even on low performance devices\n\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        this.clock = new THREE.Clock();\n      }\n\n      _createClass(FlagGroupInterface, [{\n        key: \"destroy\",\n        value: function destroy() {\n          if (this.flagpole) {\n            this.object.remove(this.flagpole.object);\n            this.flagpole.destroy();\n          }\n\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = this.flagInterfaces[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var flagInterface = _step3.value;\n              this.object.remove(flagInterface.object);\n              flagInterface.destroy();\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          this.flagInterfaces = [];\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {}\n      }, {\n        key: \"simulate\",\n        value: function simulate(deltaTime) {\n          // ChT: Raise the flag! \n          if (!window.FW_App.raiseFlags) return; // Get our own delta because the argument  may be shorter than the \n          // real time difference\n\n          var delta = this.clock.getDelta(); // Calculate offset\n\n          var flagStart = window.innerWidth * 0.21 * 2 / 3 * 1.1 * 2.2;\n          var offset = (window.innerHeight * 0.9 - flagStart) / this.duration * delta;\n          var maxY = this.flagpole.object.position.y - 4;\n\n          if (this.flagpole && this.flagInterfaces) {\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n              for (var _iterator4 = this.flagInterfaces[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var flagInterface = _step4.value;\n                if (maxY > flagInterface.object.position.y + offset) flagInterface.object.position.y += offset;else if (maxY > flagInterface.object.y) flagInterface.object.position.y = maxY;\n                maxY -= flagInterface.flag.cloth.height * 1.1;\n              }\n            } catch (err) {\n              _didIteratorError4 = true;\n              _iteratorError4 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                  _iterator4.return();\n                }\n              } finally {\n                if (_didIteratorError4) {\n                  throw _iteratorError4;\n                }\n              }\n            }\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {}\n      }]);\n\n      return FlagGroupInterface;\n    }();\n\n    FlagGroupInterface.FlagInterface = FlagInterface;\n\n    var tmp = new THREE.Vector3();\n    var worldPosition = new THREE.Vector3();\n    /**\n     * @function localizeForce\n     *\n     * @description Transforms a force vector from global space to local space.\n     *\n     * @param {THREE.Vector3} force - Vector representing a force\n     * @param {THREE.Object3D} [object] - Local object\n     */\n\n    function localizeForce(force, object) {\n      /*\n       * Converts the direction and magnitude of a given vector from\n       * world coordinate space to the local space of the given object.\n       * The given vector is expected to represent direction and magnitude\n       * only, it does not represent a position in 3D space.\n       */\n      tmp.copy(force);\n\n      if (object instanceof THREE.Object3D) {\n        // Discard world position information\n        worldPosition.setFromMatrixPosition(object.matrixWorld);\n        tmp.add(worldPosition);\n        object.worldToLocal(tmp);\n      }\n\n      return tmp;\n    }\n\n    // We make the stuff lighter, flying more horizontal\n\n    var gravity = new THREE.Vector3(0, -G * 14, 0);\n    /**\n     * @function applyGravityToCloth\n     *\n     * @description Applies downward gravity force to cloth.\n     *\n     * @param {Cloth} cloth\n     * @param {THREE.Object3D} [object]\n     */\n\n    function applyGravityToCloth(cloth, object) {\n      var particles = cloth.particles;\n      var force = localizeForce(gravity, object);\n\n      for (var i = 0, ii = particles.length; i < ii; i++) {\n        particles[i].acceleration.add(force);\n      }\n    }\n\n    var tmp$1 = new THREE.Vector3();\n\n    var tmp$2 = new THREE.Vector3();\n    /**\n     * @function applyWindForceToCloth\n     *\n     * @description Applies wind force to cloth.\n     *\n     * @param {Cloth} cloth\n     * @param {Wind} wind\n     * @param {THREE.Object3D} [object]\n     */\n\n    function applyWindForceToCloth(cloth, wind, object) {\n      var particles = cloth.particles;\n      var faces = cloth.geometry.faces;\n\n      if (wind) {\n        var force = localizeForce(wind.force, object);\n\n        for (var i = 0, ii = faces.length; i < ii; i++) {\n          var face = faces[i];\n          var normal = face.normal;\n          tmp$2.copy(normal).normalize().multiplyScalar(normal.dot(force));\n          particles[face.a].applyForce(tmp$2);\n          particles[face.b].applyForce(tmp$2);\n          particles[face.c].applyForce(tmp$2);\n        }\n      }\n    }\n\n    /**\n     * @class Module\n     * @interface\n     *\n     * @classdesc A Module encapsulates a piece of functionality that can\n     * be applied to a scene. This class is just a skeleton for other classes\n     * to inherit from.\n     *\n     * Each module should have an `init` method and a `deinit` method which\n     * should be called whenever it is added to or removed from a scene.\n     */\n    var Module =\n    /*#__PURE__*/\n    function () {\n      function Module() {\n        _classCallCheck(this, Module);\n      }\n\n      _createClass(Module, [{\n        key: \"init\",\n        value: function init() {}\n      }, {\n        key: \"deinit\",\n        value: function deinit() {}\n      }]);\n\n      return Module;\n    }();\n\n    Module.displayName = 'module';\n\n    /**\n     * @class ModuleSystem\n     *\n     * @classdesc Manages a collection of modules.\n     *\n     * @param {App} [context]\n     */\n\n    var ModuleSystem =\n    /*#__PURE__*/\n    function () {\n      function ModuleSystem(context) {\n        _classCallCheck(this, ModuleSystem);\n\n        this.context = context || this;\n        this.modules = [];\n      } // Get module by display name and index\n\n\n      _createClass(ModuleSystem, [{\n        key: \"module\",\n        value: function module(displayName) {\n          var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n          var modules = this.modules;\n\n          for (var i = 0, ii = modules.length, j = 0; i < ii; i++) {\n            var module = modules[i];\n\n            if (module.constructor.displayName === displayName) {\n              if (j === index) {\n                return module;\n              }\n\n              j++;\n            }\n          }\n\n          return null;\n        } // Add module and call `module.init`\n\n      }, {\n        key: \"add\",\n        value: function add(module) {\n          if (!(module instanceof Module)) {\n            return;\n          }\n\n          if (module.init) {\n            module.init(this.context);\n          }\n\n          this.modules.push(module);\n          return module;\n        } // Remove module and call `module.deinit`\n\n      }, {\n        key: \"remove\",\n        value: function remove(module) {\n          if (!(module instanceof Module)) {\n            return;\n          }\n\n          var modules = this.modules;\n          var index = modules.indexOf(module);\n\n          if (index < 0) {\n            return;\n          }\n\n          if (module.deinit) {\n            module.deinit(this.context);\n          }\n\n          return modules.splice(index, 1)[0];\n        }\n      }]);\n\n      return ModuleSystem;\n    }();\n\n    /**\n     * @class App\n     *\n     * @classdesc Root module and time counter.\n     *\n     * @param {Object} options\n     *   @param {THREE.Scene} options.scene\n     *   @param {THREE.Camera} options.camera\n     *   @param {THREE.WebGLRenderer} options.renderer\n     *   @param {Function} [options.onStart]\n     *   @param {Function} [options.onUpdate]\n     */\n\n    var App =\n    /*#__PURE__*/\n    function (_ModuleSystem) {\n      _inherits(App, _ModuleSystem);\n\n      function App(options) {\n        var _this;\n\n        _classCallCheck(this, App);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(App).call(this));\n        var settings = Object.assign({}, _this.constructor.defaults, options);\n        var scene = settings.scene,\n            camera = settings.camera,\n            renderer = settings.renderer;\n        var onStart = settings.onStart.bind(_assertThisInitialized(_this));\n        var onUpdate = settings.onUpdate.bind(_assertThisInitialized(_this));\n        var clock = new THREE.Clock();\n        var timestep = TIME_STEP;\n\n        var startModules = function startModules() {\n          var modules = _this.modules;\n\n          for (var i = 0, ii = modules.length; i < ii; i++) {\n            var module = modules[i];\n\n            if (module.subject && module.reset) {\n              module.reset();\n            }\n          }\n        };\n\n        var updateModules = function updateModules(deltaTime) {\n          var modules = _this.modules;\n\n          for (var i = 0, ii = modules.length; i < ii; i++) {\n            var module = modules[i];\n\n            if ((module.subject || module.interact) && module.update) {\n              module.update(deltaTime);\n            }\n          }\n        };\n\n        var render = function render() {\n          camera.lookAt(scene.position);\n          renderer.render(scene, camera);\n        };\n\n        var start = function start() {\n          onStart();\n          startModules();\n          render();\n        };\n\n        var update = function update(deltaTime) {\n          onUpdate(deltaTime);\n          updateModules(deltaTime);\n          render();\n        };\n\n        var loop = function loop() {\n          requestAnimationFrame(loop);\n\n          if (clock.running) {\n            // ChT: Animation in slow motion. Three would still call us\n            // with 60fps, but we fake half speed\n            update(Math.min(clock.getDelta() / 2, timestep));\n          }\n        }; // Init\n\n\n        scene.add(camera);\n        clock.start();\n        start();\n        loop(); // Public properties and methods\n\n        _this.scene = scene;\n        _this.renderer = renderer;\n        _this.camera = camera;\n        _this.canvas = renderer.domElement;\n        _this.clock = clock;\n        _this.timestep = timestep;\n        _this.start = start;\n        _this.update = update;\n        return _this;\n      }\n\n      return App;\n    }(ModuleSystem);\n\n    App.defaults = {\n      onStart: function onStart() {},\n      onUpdate: function onUpdate() {}\n    };\n\n    /**\n     * @class AnimationModule\n     *\n     * @classdesc Allow animation to be paused and continued.\n     */\n\n    var AnimationModule =\n    /*#__PURE__*/\n    function (_Module) {\n      _inherits(AnimationModule, _Module);\n\n      function AnimationModule() {\n        var _this;\n\n        _classCallCheck(this, AnimationModule);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationModule).call(this));\n        _this.app = null;\n        return _this;\n      }\n\n      _createClass(AnimationModule, [{\n        key: \"init\",\n        value: function init(app) {\n          this.app = app;\n        }\n      }, {\n        key: \"deinit\",\n        value: function deinit() {\n          if (this.play) {\n            this.play();\n          }\n        }\n      }, {\n        key: \"play\",\n        value: function play() {\n          var clock = this.app.clock;\n\n          if (!clock.running) {\n            clock.start();\n          }\n        }\n      }, {\n        key: \"pause\",\n        value: function pause() {\n          this.app.clock.stop();\n        }\n      }, {\n        key: \"step\",\n        value: function step() {\n          var _this$app = this.app,\n              clock = _this$app.clock,\n              timestep = _this$app.timestep;\n\n          if (!clock.running) {\n            clock.elapsedTime += timestep;\n            this.app.update(timestep);\n          }\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          var clock = this.app.clock;\n          clock.startTime = 0;\n          clock.oldTime = 0;\n          clock.elapsedTime = 0;\n          this.app.start();\n        }\n      }]);\n\n      return AnimationModule;\n    }(Module);\n\n    AnimationModule.displayName = 'animationModule';\n\n    /**\n     * @class ResizeModule\n     *\n     * @classdesc Updates canvas size on window resize.\n     */\n\n    var ResizeModule =\n    /*#__PURE__*/\n    function (_Module) {\n      _inherits(ResizeModule, _Module);\n\n      function ResizeModule() {\n        var _this;\n\n        _classCallCheck(this, ResizeModule);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(ResizeModule).call(this));\n        _this.app = null;\n        _this.resize = _this.resize.bind(_assertThisInitialized(_this));\n        return _this;\n      }\n\n      _createClass(ResizeModule, [{\n        key: \"init\",\n        value: function init(app) {\n          this.app = app;\n          window.addEventListener('resize', this.resize);\n          this.resize();\n        }\n      }, {\n        key: \"deinit\",\n        value: function deinit() {\n          window.removeEventListener('resize', this.resize);\n        }\n      }, {\n        key: \"resize\",\n        value: function resize() {\n          var _this$app = this.app,\n              scene = _this$app.scene,\n              camera = _this$app.camera,\n              renderer = _this$app.renderer;\n          var parentElement = renderer.domElement.parentElement;\n          var canvasHeight = 1;\n          var canvasWidth = 1; // If canvas is added to DOM\n\n          if (parentElement) {\n            canvasWidth = parentElement.clientWidth;\n            canvasHeight = parentElement.clientHeight;\n          } // Update scene\n\n\n          camera.aspect = canvasWidth / canvasHeight;\n          camera.updateProjectionMatrix();\n          renderer.setSize(canvasWidth, canvasHeight);\n          renderer.render(scene, camera);\n        }\n      }]);\n\n      return ResizeModule;\n    }(Module);\n\n    ResizeModule.displayName = 'resizeModule';\n\n    var PropertyValidator =\n    /*#__PURE__*/\n    function () {\n      function PropertyValidator(validators) {\n        _classCallCheck(this, PropertyValidator);\n\n        this.validators = validators || {};\n      }\n\n      _createClass(PropertyValidator, [{\n        key: \"validate\",\n        value: function validate(options, strict) {\n          var validators = this.validators;\n\n          if (isObject(options)) {\n            return Object.keys(options).reduce(function (result, key) {\n              var value = options[key];\n\n              if (typeof value !== 'undefined') {\n                if (validators[key]) {\n                  var validated = validators[key](value);\n\n                  if (validated != null) {\n                    result[key] = validated;\n                  }\n                } else if (!strict) {\n                  result[key] = value;\n                }\n              }\n\n              return result;\n            }, {});\n          }\n\n          return {};\n        }\n      }]);\n\n      return PropertyValidator;\n    }();\n\n    function createPropertyValidator(validators) {\n      var propertyValidator = new PropertyValidator(validators);\n      return function (options, strict) {\n        return propertyValidator.validate(options, strict);\n      };\n    }\n\n    /**\n     * @class ControlModule\n     * @interface\n     *\n     * @classdesc A ControlModule is a wrapper that provides an interface\n     * between the main app and a scene object.\n     */\n\n    var ControlModule =\n    /*#__PURE__*/\n    function (_Module) {\n      _inherits(ControlModule, _Module);\n\n      function ControlModule() {\n        _classCallCheck(this, ControlModule);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(ControlModule).apply(this, arguments));\n      }\n\n      return ControlModule;\n    }(Module);\n\n    ControlModule.displayName = 'controlModule';\n    ControlModule.Subject = Object;\n\n    /**\n     * @class FlagModule\n     *\n     * @classdesc An interface for a single flag.\n     *\n     * @param {Object} [subject]\n     * @param {THREE.Object3D} [context]\n     */\n\n    var FlagModule =\n    /*#__PURE__*/\n    function (_ControlModule) {\n      _inherits(FlagModule, _ControlModule);\n\n      function FlagModule(subject, context) {\n        var _this;\n\n        _classCallCheck(this, FlagModule);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(FlagModule).call(this));\n        _this.subject = subject || null;\n        _this.context = context || null;\n        _this.configOptions = Object.assign({}, _this.constructor.Subject.defaults);\n        return _this;\n      }\n\n      _createClass(FlagModule, [{\n        key: \"init\",\n        value: function init(app) {\n          this.subject = this.subject || new this.constructor.Subject();\n\n          if (!this.context) {\n            app.scene.add(this.subject.object);\n          }\n        }\n      }, {\n        key: \"deinit\",\n        value: function deinit(app) {\n          if (!this.context) {\n            app.scene.remove(this.subject.object);\n            this.subject.destroy();\n          }\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          this.subject.reset();\n          this.subject.render();\n        }\n      }, {\n        key: \"update\",\n        value: function update(deltaTime) {\n          this.subject.simulate(deltaTime);\n          this.subject.render();\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(options, callback) {\n          var _this2 = this;\n\n          if (isObject(options)) {\n            this.subject.setOptions(Object.assign(this.configOptions, this.constructor.validate(options)), function (flag) {\n              if (callback) {\n                callback(_this2.configOptions);\n              }\n            });\n          }\n        }\n      }]);\n\n      return FlagModule;\n    }(ControlModule);\n\n    FlagModule.displayName = 'flagModule';\n    FlagModule.Subject = FlagInterface;\n    FlagModule.validate = createPropertyValidator({\n      topEdge: function topEdge(value) {\n        if (hasValue(Side, value)) {\n          return value;\n        } else {\n          console.error('FlagWaver.FlagModule.option: Invalid value.');\n        }\n      },\n      hoisting: function hoisting(value) {\n        if (hasValue(Hoisting, value)) {\n          return value;\n        } else {\n          console.error('FlagWaver.FlagModule.option: Invalid value.');\n        }\n      },\n      width: function width(value) {\n        var n = Number(value);\n\n        if (isNumeric(value) && n > 0) {\n          return n;\n        } else if (value === 'auto') {\n          return value;\n        } else {\n          console.error('FlagWaver.FlagModule.option: Invalid value.');\n        }\n      },\n      height: function height(value) {\n        var n = Number(value);\n\n        if (isNumeric(value) && n > 0) {\n          return n;\n        } else if (value === 'auto') {\n          return value;\n        } else {\n          console.error('FlagWaver.FlagModule.option: Invalid value.');\n        }\n      },\n      mass: function mass(value) {\n        var n = Number(value);\n\n        if (isNumeric(value) && n >= 0) {\n          return n;\n        } else {\n          console.error('FlagWaver.FlagModule.option: Invalid value.');\n        }\n      },\n      granularity: function granularity(value) {\n        var n = Math.round(value);\n\n        if (isNumeric(value) && n > 0) {\n          return n;\n        } else {\n          console.error('FlagWaver.FlagModule.option: Invalid value.');\n        }\n      },\n      imgSrc: function imgSrc(value) {\n        if (typeof value === 'string') {\n          return value;\n        } else {\n          console.error('FlagWaver.FlagModule.option: Invalid value.');\n        }\n      },\n      flagpoleType: function flagpoleType(value) {\n        if (hasValue(FlagpoleType, value)) {\n          return value;\n        } else {\n          console.error('FlagWaver.FlagModule.option: Invalid value.');\n        }\n      }\n    });\n\n    /**\n     * @class FlagGroupModule\n     *\n     * @classdesc An interface for a flagpole and its flag.\n     *\n     * @param {Object} [subject]\n     * @param {THREE.Object3D} [context]\n     */\n\n    var FlagGroupModule =\n    /*#__PURE__*/\n    function (_ControlModule) {\n      _inherits(FlagGroupModule, _ControlModule);\n\n      function FlagGroupModule(flagOpt) {\n        var _this;\n\n        _classCallCheck(this, FlagGroupModule);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(FlagGroupModule).call(this));\n        _this.subject = null;\n        _this.context = null;\n        _this.flags = [];\n        _this.flagOpts = flagOpt;\n        return _this;\n      }\n\n      _createClass(FlagGroupModule, [{\n        key: \"init\",\n        value: function init(app) {\n          this.subject = new this.constructor.Subject(this.flagOpts);\n\n          if (!this.context) {\n            app.scene.add(this.subject.object);\n          }\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = this.subject.flagInterfaces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var flagInterface = _step.value;\n              this.flags.push(new FlagModule(flagInterface, this.subject.object));\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = this.flags[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var _flag = _step2.value;\n              app.add(_flag);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      }, {\n        key: \"deinit\",\n        value: function deinit(app) {\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = this.flags[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              flag = _step3.value;\n              app.remove(flag);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          if (!this.context) {\n            app.scene.remove(this.subject.object);\n            this.subject.destroy();\n          }\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          this.subject.reset();\n          this.subject.render();\n        }\n      }, {\n        key: \"update\",\n        value: function update(deltaTime) {\n          this.subject.simulate(deltaTime);\n          this.subject.render();\n        }\n      }, {\n        key: \"moveFlags\",\n        value: function moveFlags(y, offset) {\n          var ypos = y;\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = this.subject.flagInterfaces[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var flagInterface = _step4.value;\n              flagInterface.object.position.y = ypos;\n              ypos -= offset;\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n      }]);\n\n      return FlagGroupModule;\n    }(ControlModule);\n\n    FlagGroupModule.displayName = 'flagGroupModule';\n    FlagGroupModule.Subject = FlagGroupInterface;\n\n    /**\n     * @class WindModule\n     *\n     * @classdesc Adds wind to scene.\n     *\n     * @param {Wind} wind\n     */\n\n\n    var WindModule =\n    /*#__PURE__*/\n    function (_ControlModule) {\n      _inherits(WindModule, _ControlModule);\n\n      function WindModule(options) {\n        var _this;\n\n        _classCallCheck(this, WindModule);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(WindModule).call(this));\n        _this.subject = new _this.constructor.Subject();\n        _this.configOptions = Object.assign({}, _this.constructor.Subject.defaults);\n        if (options !== undefined) _this.setOptions(options);\n        return _this;\n      }\n\n      _createClass(WindModule, [{\n        key: \"update\",\n        value: function update(deltaTime) {\n          this.subject.update(deltaTime);\n        }\n      }, {\n        key: \"setOptions\",\n        value: function setOptions(options) {\n          this.subject = new this.constructor.Subject(Object.assign(this.configOptions, this.constructor.validate(options)));\n        }\n      }]);\n\n      return WindModule;\n    }(ControlModule);\n\n    WindModule.displayName = 'windModule';\n    WindModule.Subject = Wind;\n    WindModule.validate = createPropertyValidator({\n      speed: function speed(value) {\n        var n = Number(value);\n\n        if (isNumeric(value) && n >= 0) {\n          return n;\n        } else {\n          console.error('FlagWaver.WindModule.option: Invalid value.');\n        }\n      }\n    });\n\n    /**\n     * @class InteractionModule\n     * @interface\n     *\n     * @classdesc A module that mediates physical interactions.\n     *\n     * @param {string[]} [subjectTypes] - Modules of subjects that are acted upon.\n     * @param {string[]} [actionTypes] - Modules that cause an action on subjects.\n     */\n\n    var InteractionModule =\n    /*#__PURE__*/\n    function (_Module) {\n      _inherits(InteractionModule, _Module);\n\n      function InteractionModule(subjectTypes, actionTypes) {\n        var _this;\n\n        _classCallCheck(this, InteractionModule);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(InteractionModule).call(this));\n        _this.app = null;\n        _this.subjectTypes = subjectTypes || [];\n        _this.actionTypes = actionTypes || [];\n        _this.subjects = [];\n        _this.actions = [];\n        _this.needsUpdate = false;\n        return _this;\n      }\n\n      _createClass(InteractionModule, [{\n        key: \"updateModulesList\",\n        value: function updateModulesList() {\n          var app = this.app;\n\n          if (!app) {\n            return;\n          }\n\n          var modules = app.modules;\n          var subjectTypes = this.subjectTypes;\n          var actionTypes = this.actionTypes;\n          var subjects = [];\n          var actions = [];\n\n          for (var i = 0, ii = modules.length; i < ii; i++) {\n            var module = modules[i];\n\n            if (subjectTypes.indexOf(module.constructor.displayName) >= 0) {\n              subjects.push(module.subject);\n            }\n\n            if (actionTypes.indexOf(module.constructor.displayName) >= 0) {\n              actions.push(module.subject);\n            }\n          }\n\n          this.subjects = subjects;\n          this.actions = actions;\n        }\n      }, {\n        key: \"init\",\n        value: function init(app) {\n          this.app = app;\n          this.updateModulesList();\n        }\n      }, {\n        key: \"interact\",\n        value: function interact(subject, action) {}\n      }, {\n        key: \"update\",\n        value: function update(deltaTime) {\n          var interact = this.interact;\n\n          if (this.needsUpdate) {\n            this.updateModulesList();\n            this.needsUpdate = false;\n          }\n\n          var subjects = this.subjects;\n          var actions = this.actions;\n\n          if (actions.length) {\n            for (var i = 0, ii = actions.length; i < ii; i++) {\n              for (var j = 0, jl = subjects.length; j < jl; j++) {\n                interact(subjects[j], actions[i]);\n              }\n            }\n          } else {\n            for (var _j = 0, _jl = subjects.length; _j < _jl; _j++) {\n              interact(subjects[_j]);\n            }\n          }\n        }\n      }]);\n\n      return InteractionModule;\n    }(Module);\n\n    InteractionModule.displayName = 'interactionModule';\n\n    /**\n     * @class GravityModule\n     *\n     * @classdesc Applies gravity to subjects.\n     */\n\n    var GravityModule =\n    /*#__PURE__*/\n    function (_InteractionModule) {\n      _inherits(GravityModule, _InteractionModule);\n\n      function GravityModule() {\n        _classCallCheck(this, GravityModule);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(GravityModule).apply(this, arguments));\n      }\n\n      _createClass(GravityModule, [{\n        key: \"interact\",\n        value: function interact(subject) {\n          applyGravityToCloth(subject.flag.cloth, subject.flag.object);\n        }\n      }]);\n\n      return GravityModule;\n    }(InteractionModule);\n\n    GravityModule.displayName = 'gravityModule';\n\n    /**\n     * @class WindForceModule\n     *\n     * @classdesc Applies wind to subjects.\n     */\n\n    var WindForceModule =\n    /*#__PURE__*/\n    function (_InteractionModule) {\n      _inherits(WindForceModule, _InteractionModule);\n\n      function WindForceModule() {\n        _classCallCheck(this, WindForceModule);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(WindForceModule).apply(this, arguments));\n      }\n\n      _createClass(WindForceModule, [{\n        key: \"interact\",\n        value: function interact(subject, wind) {\n          applyWindForceToCloth(subject.flag.cloth, wind, subject.flag.object);\n        }\n      }]);\n\n      return WindForceModule;\n    }(InteractionModule);\n\n    WindForceModule.displayName = 'windForceModule';\n\n    // Constants\n\n    function parse(string) {\n      var result = {};\n\n      if (typeof string !== 'string') {\n        return result;\n      }\n\n      var pairs = string.split('&');\n\n      for (var i = 0, ii = pairs.length; i < ii; i++) {\n        var pairString = pairs[i];\n\n        if (pairString) {\n          var pair = pairString.split('=');\n          var key = pair[0];\n\n          if (key) {\n            // Set value to null if '=' sign is not present\n            result[key] = typeof pair[1] !== 'undefined' ? pair.slice(1).join('=') : null;\n          }\n        }\n      }\n\n      return result;\n    }\n    function stringify(object) {\n      var keys = Object.keys(object);\n      var pairs = [];\n\n      for (var i = 0, ii = keys.length; i < ii; i++) {\n        var key = keys[i];\n        var value = object[key];\n\n        if (value === null) {\n          pairs.push(key);\n        } else if (typeof value !== 'undefined') {\n          pairs.push(key + '=' + value);\n        }\n      }\n\n      return pairs.join('&');\n    }\n\n    var fieldDefaults = {\n      defaultValue: '',\n      parse: function parse$$1(param) {\n        return param;\n      },\n      stringify: function stringify$$1(value) {\n        return value;\n      }\n    };\n\n    function keysToLowerCase(object) {\n      return Object.keys(object).reduce(function (result, key) {\n        result[key.toLowerCase()] = object[key];\n        return result;\n      }, {});\n    }\n\n    function isIgnored(field, value) {\n      return value === field.defaultValue || value === '' || value == null;\n    }\n\n    var ParamState =\n    /*#__PURE__*/\n    function () {\n      function ParamState(fields) {\n        _classCallCheck(this, ParamState);\n\n        this.fields = Object.keys(fields).reduce(function (result, key) {\n          result[key] = Object.assign({}, fieldDefaults, fields[key]);\n          return result;\n        }, {});\n      }\n\n      _createClass(ParamState, [{\n        key: \"parse\",\n        value: function parse$$1(string) {\n          var fields = this.fields;\n          var params = keysToLowerCase(parse(string));\n          return Object.keys(fields).reduce(function (state, key) {\n            var field = fields[key];\n            var param = params[key];\n            var value = param && field.parse(param);\n            state[key] = !isIgnored(field, value) ? value : field.defaultValue;\n            return state;\n          }, {});\n        }\n      }, {\n        key: \"stringify\",\n        value: function stringify$$1(state) {\n          var fields = this.fields;\n          return stringify(Object.keys(fields).reduce(function (params, key) {\n            var field = fields[key];\n            var value = state[key];\n\n            if (!isIgnored(field, value)) {\n              params[key] = field.stringify(value);\n            }\n\n            return params;\n          }, {}));\n        }\n      }]);\n\n      return ParamState;\n    }();\n\n    var _window = window,\n        history = _window.history,\n        location = _window.location; // Check if browser supports the History API\n\n    var isHistorySupported = !!(history && history.replaceState); // Check if browser allows history changes in current context\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=529313\n\n    var isHistoryAllowed = function () {\n      try {\n        history.replaceState(null, '', location.href);\n      } catch (e) {\n        {\n          console.log('Cannot push states to history object.');\n          console.log(e.message);\n        }\n\n        return false;\n      }\n\n      return true;\n    }();\n\n    var initialized = false; // Functions\n    //\n\n    if (window.getParameterByName === undefined) {\n      window.getParameterByName = function (name, def) {\n        name = name.replace(/[\\[]/, \"\\\\\\[\").replace(/[\\]]/, \"\\\\\\]\");\n        var regexS = \"[\\\\?&]\" + name + \"=([^&#]*)\";\n        var regex = new RegExp(regexS);\n        var results = regex.exec(window.location.search);\n\n        if (results == null && parent != undefined) {\n\n          results = regex.exec(parent.window.location.search);\n        }\n\n        if (results == null) return def;else return decodeURIComponent(results[1].replace(/\\+/g, \" \"));\n      };\n    }\n\n    function fromQuery() {\n      var flags = [];\n\n      for (var i = 0; i < 4; i++) {\n        var imgURL = getParameterByName('' + (i + 1), null) || 'AUT';\n        flags.push(imgURL);\n      }\n\n      return flags;\n    }\n\n    function buildScene() {\n      var scene = new THREE.Scene();\n      scene.fog = new THREE.Fog(0x000000, 1000, 10000);\n      scene.fog.color.setHSL(0.6, 1, 0.9);\n      return scene;\n    }\n\n    function buildCamera() {\n      var defaultAngle = 30;\n      var angle = parseInt(getParameterByName('cameraAngle', defaultAngle)); // ChT: Orthographic camera instead of perspective camera:\n      // Basically we are rendering a flat 2D scene and equal distances are more\n      // important than a 3D look\n      // We still calculate the z distance based on the view angle\n\n      /*    \n        const camera = new THREE.PerspectiveCamera(\n            angle,\n            window.innerWidth / window.innerHeight,\n            1,\n            10000\n        );\n      */\n\n      var camera = new THREE.OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 1, 10000);\n      camera.position.x = parseInt(getParameterByName('cameraX', '0'));\n      camera.position.y = parseInt(getParameterByName('cameraY', '0'));\n      camera.position.z = parseInt(getParameterByName('cameraZ', window.innerHeight / 2 / Math.tan(angle / 2 * Math.PI / 180)));\n      return camera;\n    }\n\n    function buildRenderer() {\n      var renderer = new THREE.WebGLRenderer({\n        antialias: true,\n        alpha: true\n      });\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      renderer.gammaInput = true;\n      renderer.gammaOutput = true;\n      renderer.shadowMap.enabled = true;\n      return renderer;\n    }\n\n    function initLights(app) {\n      var scene = app.scene;\n      scene.add(new THREE.AmbientLight(0x222222));\n      var light1 = new THREE.DirectionalLight(0xffffff, 1.75);\n      var d = 300;\n      light1.color.setHSL(0.6, 1, 0.9375);\n      light1.position.set(50, 175, 100);\n      light1.position.multiplyScalar(1.3);\n      light1.castShadow = true;\n      light1.shadowMapWidth = 2048;\n      light1.shadowMapHeight = 2048;\n      light1.shadowCameraTop = d;\n      light1.shadowCameraLeft = -d;\n      light1.shadowCameraBottom = -d;\n      light1.shadowCameraRight = d;\n      light1.shadowCameraFar = 1000;\n      light1.shadowDarkness = 0.5;\n      scene.add(light1);\n      var light2 = new THREE.DirectionalLight(0xffffff, 0.35);\n      light2.color.setHSL(0.3, 0.5, 0.75);\n      light2.position.set(0, -1, 0);\n      scene.add(light2);\n    }\n\n    function buildApp() {\n      // Initialized location for flags from query parameter\n      window.imageLocation = getParameterByName('flagLocation', window.imageLocation);\n      var flags = fromQuery();\n      var imgWidth = getParameterByName('flagWidth', 'auto');\n      var imgHeight = getParameterByName('flagHeight', 'auto');\n      var duration = parseInt(getParameterByName('duration', 30));\n      var app = new App({\n        scene: buildScene(),\n        camera: buildCamera(),\n        renderer: buildRenderer()\n      });\n      initLights(app);\n      app.add(new ResizeModule());\n      app.add(new AnimationModule());\n      app.add(new WindModule({\n        speed: getParameterByName('windSpeed', 100)\n      })); // ChT: Add flagpoles for 2nd, 1st, and 3rd / 4th place\n\n      app.add(new FlagGroupModule({\n        imgSrc: flags[1],\n        width: imgWidth,\n        height: imgHeight,\n        duration: duration\n      }));\n      app.add(new FlagGroupModule({\n        imgSrc: flags[0],\n        width: imgWidth,\n        height: imgHeight,\n        duration: duration\n      }));\n      app.add(new FlagGroupModule({\n        imgSrc: flags[2],\n        width: imgWidth,\n        height: imgHeight,\n        duration: duration\n      }));\n      app.add(new FlagGroupModule({\n        imgSrc: flags[3],\n        width: imgWidth,\n        height: imgHeight,\n        duration: duration\n      })); // ChT: And put them in an orderly way, 2nd, 1st, 3rd and 4th\n      // Distance between poles is 0.24 x innerWidth, flag width is 0.21 x innerWidth\n      // Calculate offset of flag from bottom to give room for 2 flags\n      // var flagStart = app.module(FlagModule.displayName, 0).subject.flag.cloth.height * 2.1;\n\n      var flagDistance = window.innerWidth * 0.21 * 2 / 3 * 1.1;\n      if (Number.isInteger(getParameterByName('flagHeight', 'auto'))) flagDistance = parseInt(getParameterByName('flagHeight', 'auto')) * 1.1;\n      var flagStart = flagDistance * 2.2;\n      app.module(FlagGroupModule.displayName, 0).subject.object.position.set(-(window.innerWidth * 0.45), window.innerHeight * 0.6 / 2, 0);\n      app.module(FlagGroupModule.displayName, 0).moveFlags(-(window.innerHeight + window.innerHeight * 0.6) / 2 + flagStart, flagDistance);\n      app.module(FlagGroupModule.displayName, 1).subject.object.position.set(-(window.innerWidth * 0.21), window.innerHeight * 0.8 / 2, 0);\n      app.module(FlagGroupModule.displayName, 1).moveFlags(-(window.innerHeight + window.innerHeight * 0.8) / 2 + flagStart, flagDistance);\n      app.module(FlagGroupModule.displayName, 2).subject.object.position.set(+(window.innerWidth * 0.03), window.innerHeight * 0.4 / 2, 0);\n      app.module(FlagGroupModule.displayName, 2).moveFlags(-(window.innerHeight + window.innerHeight * 0.4) / 2 + flagStart, flagDistance);\n      app.module(FlagGroupModule.displayName, 3).subject.object.position.set(+(window.innerWidth * 0.27), window.innerHeight * 0.4 / 2, 0);\n      app.module(FlagGroupModule.displayName, 3).moveFlags(-(window.innerHeight + window.innerHeight * 0.4) / 2 + flagStart, flagDistance);\n      app.add(new GravityModule(['flagModule']));\n      app.add(new WindForceModule(['flagModule'], ['windModule']));\n      return app;\n    }\n\n    function init() {\n      // Prevent multiple initialization\n      if (initialized) {\n        throw new Error('Already initialized.');\n      }\n\n      var app = buildApp();\n      initialized = true;\n      var prestart = getParameterByName('prestart', 1);\n\n      if (prestart > 0) {\n        setTimeout(function () {\n          // remove (in) visibility\n          $('.bg-sky').css('visibility', '');\n          app.raiseFlags = true;\n        }, prestart * 1000);\n      } else {\n        // remove (in) visibility\n        $('.bg-sky').css('visibility', '');\n        app.raiseFlags = true;\n      }\n\n      return app;\n    }\n\n    /**\n     * Flag Waver\n     *\n     * Simulate a flag waving in the breeze right in your browser window.\n     *\n     * /u/krikienoid\n     *\n     */\n    var app; //\n    // Flag Waver UI\n    //\n\n    (function (window, document, $) {\n      //\n      // Vars\n      //\n      //\n      //\n      // Init\n      //\n      $(document).ready(function () {\n        //\n        // Init\n        //\n        // Init flagWaver and append renderer to DOM\n        app = init();\n        window.FW_App = app;\n        $('.js-flag-canvas').append(app.renderer.domElement);\n        window.dispatchEvent(new window.Event('resize')); // On click anywhere in browser start raising the flags\n\n        $('body').on('click', function () {\n          FW_App.raiseFlags = true;\n        });\n      });\n    })(window, document, jQuery);\n\n    /*!\n     * FlagWaver\n     * @author krikienoid / https://github.com/krikienoid\n     *\n     * A web app for simulating a waving flag.\n     */\n\n}(THREE));\n"],"file":"app.js"}